<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>环环相扣</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        body {
            color: #999;
            perspective: 30em;
        }

        canvas {
            display: block;
           /*  background: darkblue; */
           transform-origin:0 0;
        }
    </style>
</head>
<body>
<canvas id="circleBox"></canvas>
<script src="${contextPath}/static/phm/asserts/js/jquery-2.2.4.js"></script>
<script>
	/*屏幕描述
	一共 7x3 个屏幕，每一块屏幕是1360x768，
	总共的大小就是9520x2304，比预计像素少7x6=42个像素。*/
	
	var pageH = $(window).height();
	var pageW = pageH * 16 * 7 / (9 * 3);
	var bodyScale = pageH / 280;
	var bodyFontSize = bodyScale * 100 + "%";
	if (pageH > 2300) { // 如果是大屏幕(2304)
	pageW -= 47
	}
	function pageResize() {
	$("body").css("font-size", bodyFontSize);
	$("#content").css("width", pageW);
	$(".fullScreen_map").css("width", pageW);//全屏页面是绝对定位,宽度100%只能取自屏幕
	console.log("~~~~~~~~~窗口高度：" + pageH + ",\n宽度:"+pageW+" \nbody字号：" + bodyFontSize)
	}
	pageResize();
	
    var $can = $("canvas#circleBox");
    var w, h;

    function resize() {
        w = window.innerWidth/bodyScale;
        h = window.innerHeight/bodyScale;
        $can.attr({
            width: w,
            height: h
        }).css("transform","scale("+bodyScale+")");
        console.log(w, h);
    }
    resize();
    window.onresize = function(){resize();}
    var color = "#fff";
    var ctx = $can[0].getContext("2d");
    var t1;

    ctx.lineWidth = 2;//每个细圈的线宽
    var fps = 10;//帧频
    var circleNum = 4;//多少组圆圈,也会影响速度
    var rMin = 20; //起始半径
    var rMax = w < h ? w / 2 : h / 2; //起始半径
    var vr = 2;//变化速率
    var circleDelay = (rMax - rMin) * (1000 / fps) / (vr) / circleNum - (30 - vr * 12);//每组圆圈的延迟, 括号内减数用来微调首尾衔接
    var circles = [];

    //    console.log("circleDelay：",circleDelay,"计算周期：",w*(1000/fps)/(2*vr));

    function Circle() {
    }

    Circle.prototype = {
        init: function () {
            this.r = rMin; //半径
            this.vr = vr;//放大速率人
            this.a = 1;//透明度
            this.vaOuter = .93;//消失变化率
            this.vaInner = .85;//每个圈内部拖尾变化率
            this.circleStrokeNum = 16;//每组圈数,和线宽共同影响厚度

        },
        draw: function () {//绘制一组圆圈
            for (var i = 0; i < this.circleStrokeNum; i++) {
                ctx.strokeStyle = "rgba(94,209,255," + this.a * Math.pow(this.vaInner, i) + ")";
                ctx.beginPath();
                var r = (this.r - i > 0) ? this.r - i : 0;
                ctx.arc(w / 2, h / 2, r, 0, Math.PI * 2);
                ctx.stroke();
            }
            this.update();

        },

        update: function () {//更新圆圈大小
            if (this.r < rMax) {
                this.r += this.vr;
                if (this.r > (2 * rMax / 3)) {
                    this.a *= this.vaOuter;
                }
            } else {
                this.init();
//                console.log("时间差：",new Date()-t1);
            }
        }
    };


    function circleByCircle() {
        for (var i = 0; i < circleNum; i++) {
            setTimeout(function () {
                var circle = new Circle();
                circle.init();
                circles.push(circle);
            }, circleDelay * i)
        }
        t1 = new Date();
        setInterval(function () {
            ctx.clearRect(0, 0, w, h);
//            console.log("------清除画布");
            for (var j = 0; j < circles.length; j++) {
                circles[j].draw();
            }
        }, 1000 / fps)
    }

    $(function () {
        circleByCircle();

    })


</script>
</body>
</html>